import 'dart:async';

import 'package:flutter/foundation.dart' show setEquals;
import 'package:flutter/material.dart';
import '../src/rust/third_party/holon_api.dart' show Value;
// Freezed extensions are automatically available via 'part of' declarations
import '../src/rust/third_party/holon_api/render_types.dart';
import '../utils/value_converter.dart' show valueToDynamic;
import '../utils/render_spec_extension.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:outliner_view/outliner_view.dart';
import '../src/rust/third_party/holon_api/streaming.dart'
    show BatchMapChangeWithMetadata, MapChange, MapChangePatterns;
import 'render_interpreter.dart';
import '../data/row_data_block_ops.dart';
import 'reactive_query_notifier.dart';
import 'list_item_widget.dart';
import '../providers/settings_provider.dart';
import '../styles/app_styles.dart';

/// Event type for CDC (Change Data Capture) streaming.
enum RowEventType { added, updated, removed }

class RowEvent {
  final RowEventType type;
  final String rowId;
  final Map<String, dynamic>? data;

  const RowEvent({required this.type, required this.rowId, this.data});
}

/// Convert MapChange from Rust to RowEvent for widget consumption
RowEvent rowChangeToRowEvent(
  MapChange rowChange,
  Map<String, dynamic> Function(Map<String, Value>) valueConverter,
) {
  return rowChange.when(
    created: (data, origin) {
      // Convert data first, then extract entity ID from converted data
      final convertedData = valueConverter(data);
      final id = convertedData['id']?.toString() ?? '';
      if (id.isEmpty) {
        debugPrint(
          '[rowChangeToRowEvent] WARNING: Created event has empty ID! convertedData=$convertedData',
        );
      }
      return RowEvent(type: RowEventType.added, rowId: id, data: convertedData);
    },
    updated: (id, data, origin) {
      // Convert data first
      final convertedData = valueConverter(data);
      // Use the id parameter (which should already be a string from Rust)
      // But also verify it matches the converted data's id field
      final entityId = convertedData['id']?.toString() ?? id;
      debugPrint(
        '[rowChangeToRowEvent] Updated event: param id=$id, extracted id=$entityId, data keys=${convertedData.keys.toList()}',
      );
      return RowEvent(
        type: RowEventType.updated,
        rowId: entityId,
        data: convertedData,
      );
    },
    fieldsChanged: (entityId, fields, origin) {
      debugPrint(
        '[rowChangeToRowEvent] Fields changed event: entityId=$entityId, fields=$fields',
      );
      final data = Map.fromEntries(
        fields.map((field) => MapEntry(field.$1, valueToDynamic(field.$3))),
      );
      return RowEvent(type: RowEventType.updated, rowId: entityId, data: data);
    },
    deleted: (id, origin) {
      debugPrint('[rowChangeToRowEvent] Deleted event: id=$id');
      return RowEvent(type: RowEventType.removed, rowId: id, data: null);
    },
  );
}

// Provider is generated by @riverpod annotation in reactive_query_notifier.dart

/// Widget that renders a PRQL query with reactive updates via CDC streaming.
///
/// This is the main entry point for rendering PRQL queries in Flutter.
/// It handles:
/// - Streaming CDC events from Rust
/// - Maintaining keyed widget cache for efficient updates
/// - Building UI from RenderSpec using RenderInterpreter
///
/// Usage:
/// ```dart
/// ReactiveQueryWidget(
///   sql: "SELECT * FROM blocks WHERE parent_id = ?",
///   params: {"parent_id": "root"},
///   renderSpec: spec,
///   onOperation: (name, params) => executeOperation(name, params),
/// )
/// ```
class ReactiveQueryWidget extends ConsumerWidget {
  /// SQL query to execute (compiled from PRQL).
  final String sql;

  /// Query parameters.
  final Map<String, dynamic> params;

  /// Render specification (AST root).
  final RenderSpec renderSpec;

  /// Optional view name to render (for multi-view queries).
  /// If null, uses renderSpec.defaultView.
  final String? viewName;

  /// Stream of change events from Rust (BatchMapChangeWithMetadata to preserve trace context).
  final Stream<BatchMapChangeWithMetadata>? changeStream;

  /// Initial data to populate the cache.
  final List<Map<String, dynamic>>? initialData;

  /// Callback for executing operations (indent, outdent, etc.).
  /// Parameters: entityName, operationName, params
  final Future<void> Function(
    String entityName,
    String operationName,
    Map<String, dynamic> params,
  )?
  onOperation;

  /// Callback for syncing providers (e.g., Todoist).
  final Future<void> Function()? onSync;

  const ReactiveQueryWidget({
    super.key,
    required this.sql,
    required this.params,
    required this.renderSpec,
    this.viewName,
    this.changeStream,
    this.initialData,
    this.onOperation,
    this.onSync,
  });

  /// Convert Value to native Dart type.
  static Map<String, dynamic> _valueToNative(Map<String, Value> valueMap) {
    return valueMap.map((key, value) => MapEntry(key, valueToDynamic(value)));
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Create a unique key for this query instance based on SQL and params
    final queryKey = '${sql}_${params.toString()}';

    // Create provider override for this specific query instance
    final queryParams = ReactiveQueryParams(
      queryKey: queryKey,
      sql: sql,
      params: params,
      changeStream: changeStream,
      initialData: initialData,
      onOperation: onOperation,
      onSync: onSync,
      valueConverter: _valueToNative,
    );

    // Use the provider directly - family mechanism handles separate instances
    return _ReactiveQueryWidgetContent(
      queryKey: queryKey,
      queryParams: queryParams,
      renderSpec: renderSpec,
      viewName: viewName,
      onOperation: onOperation,
      onSync: onSync,
    );
  }
}

/// Wrapper for structural state that uses content-based equality.
///
/// This allows `_ReactiveQueryWidgetContent` to only rebuild when the
/// STRUCTURE changes (loading/error state, row IDs), not when row CONTENT
/// changes. Individual tree nodes watch their own content via TreeNodeWidget.
class _StructuralState {
  final bool isLoading;
  final bool hasError;
  final Object? error;
  final Set<String> rowIds;

  const _StructuralState({
    required this.isLoading,
    required this.hasError,
    this.error,
    required this.rowIds,
  });

  @override
  bool operator ==(Object other) =>
      other is _StructuralState &&
      isLoading == other.isLoading &&
      hasError == other.hasError &&
      error == other.error &&
      setEquals(rowIds, other.rowIds);

  @override
  int get hashCode => Object.hash(isLoading, hasError, error, Object.hashAll(rowIds));
}

/// Internal widget that uses the provider
class _ReactiveQueryWidgetContent extends ConsumerWidget {
  final String queryKey;
  final ReactiveQueryParams queryParams;
  final RenderSpec renderSpec;
  final String? viewName;
  final Future<void> Function(String, String, Map<String, dynamic>)?
  onOperation;
  final Future<void> Function()? onSync;

  const _ReactiveQueryWidgetContent({
    required this.queryKey,
    required this.queryParams,
    required this.renderSpec,
    this.viewName,
    this.onOperation,
    this.onSync,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Watch only STRUCTURAL changes (loading/error state, row IDs)
    // This prevents rebuilding the entire tree when only row content changes.
    // Individual tree nodes watch their own content via TreeNodeWidget.
    final structural = ref.watch(
      reactiveQueryStateProvider(queryParams).select(
        (asyncState) => asyncState.when(
          data: (state) => _StructuralState(
            isLoading: false,
            hasError: false,
            rowIds: state.rowCache.keys.toSet(),
          ),
          loading: () => const _StructuralState(
            isLoading: true,
            hasError: false,
            rowIds: {},
          ),
          error: (e, _) => _StructuralState(
            isLoading: false,
            hasError: true,
            error: e,
            rowIds: {},
          ),
        ),
      ),
    );

    if (structural.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (structural.hasError) {
      return Center(child: Text('Error: ${structural.error}'));
    }

    if (structural.rowIds.isEmpty) {
      // Need full state for empty view (has sync button etc)
      final asyncState = ref.read(reactiveQueryStateProvider(queryParams));
      return asyncState.maybeWhen(
        data: (queryState) => _buildEmpty(ref, queryState),
        orElse: () => const Center(child: Text('No data')),
      );
    }

    // Get full state using read() - doesn't trigger rebuilds
    final asyncState = ref.read(reactiveQueryStateProvider(queryParams));
    return asyncState.maybeWhen(
      data: (queryState) => _buildFromCache(ref, queryState),
      orElse: () => const SizedBox.shrink(),
    );
  }

  /// Build UI from cached row data.
  Widget _buildFromCache(WidgetRef ref, ReactiveQueryState queryState) {
    // Get the root expression to determine how to render
    final rootExpr = renderSpec.getViewStructure(viewName);
    final interpreter = RenderInterpreter();

    final colors = ref.watch(appColorsProvider);

    // If root is a list(), outline(), or tree() function, build appropriate view
    return rootExpr.when(
      functionCall: (name, args, _) {
        if (name == 'list') {
          return _buildListView(ref, queryState, args, interpreter, colors);
        }
        if (name == 'outline') {
          return _buildOutlineView(ref, queryState, args, interpreter, colors);
        }
        if (name == 'tree') {
          return _buildTreeView(ref, queryState, args, interpreter, colors);
        }
        // For non-list/outline/tree roots, render single item
        return _buildSingleItem(queryState, rootExpr, interpreter, colors);
      },
      columnRef: (_) =>
          _buildSingleItem(queryState, rootExpr, interpreter, colors),
      literal: (_) =>
          _buildSingleItem(queryState, rootExpr, interpreter, colors),
      binaryOp: (_, __, ___) =>
          _buildSingleItem(queryState, rootExpr, interpreter, colors),
      array: (_) => _buildSingleItem(queryState, rootExpr, interpreter, colors),
      object: (_) =>
          _buildSingleItem(queryState, rootExpr, interpreter, colors),
    );
  }

  /// Build empty state.
  Widget _buildEmpty(WidgetRef ref, ReactiveQueryState queryState) {
    if (onSync != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text(
              'No data',
              style: TextStyle(fontSize: 16, color: Colors.grey),
            ),
            const SizedBox(height: 16),
            ElevatedButton.icon(
              onPressed: queryState.isSyncing
                  ? null
                  : () => ref
                        .read(reactiveQueryStateProvider(queryParams).notifier)
                        .sync(),
              icon: queryState.isSyncing
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Icon(Icons.sync),
              label: Text(
                queryState.isSyncing ? 'Syncing...' : 'Sync from Todoist',
              ),
            ),
          ],
        ),
      );
    }
    return const Center(child: Text('No data'));
  }

  /// Build ListView with virtualization and keyed widgets.
  Widget _buildListView(
    WidgetRef ref,
    ReactiveQueryState queryState,
    List<Arg> listArgs,
    RenderInterpreter interpreter,
    AppColors colors,
  ) {
    // Extract item template from list args
    final itemExpr = listArgs
        .firstWhere(
          (arg) => arg.name == 'item_template',
          orElse: () =>
              throw ArgumentError('list() requires "item_template" argument'),
        )
        .value;

    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      itemCount: queryState.rowOrder.length,
      itemBuilder: (context, index) {
        final rowId = queryState.rowOrder[index];

        // Get previous row data for operations that need context
        Map<String, dynamic>? previousRowData;
        if (index > 0) {
          final previousRowId = queryState.rowOrder[index - 1];
          previousRowData = queryState.rowCache[previousRowId];
        }

        // Use ListItemWidget for per-item reactive updates
        // Each item watches only its own row data via Riverpod select()
        return ListItemWidget(
          key: ValueKey(rowId),
          rowId: rowId,
          queryParams: queryParams,
          interpreter: interpreter,
          itemExpr: itemExpr,
          rowTemplates: renderSpec.rowTemplates,
          onOperation: onOperation,
          rowIndex: index,
          previousRowData: previousRowData,
        );
      },
    );
  }

  /// Build AnimatedTreeView from tree() function.
  Widget _buildTreeView(
    WidgetRef ref,
    ReactiveQueryState queryState,
    List<Arg> treeArgs,
    RenderInterpreter interpreter,
    AppColors colors,
  ) {
    final parentIdArg = treeArgs.firstWhere(
      (arg) => arg.name == 'parent_id',
      orElse: () => throw ArgumentError('tree() requires "parent_id" argument'),
    );
    final sortKeyArg = treeArgs.firstWhere(
      (arg) => arg.name == 'sortkey' || arg.name == 'sort_key',
      orElse: () => throw ArgumentError(
        'tree() requires "sortkey" or "sort_key" argument',
      ),
    );

    final parentIdColumn = _evaluateColumnName(parentIdArg.value);
    final sortKeyColumn = _evaluateColumnName(sortKeyArg.value);
    final rootExpr = renderSpec.getViewStructure(viewName);

    final dummyRowData = queryState.rowCache.values.isNotEmpty
        ? queryState.rowCache.values.first
        : <String, dynamic>{};

    // Extract entity name from: operations, then first row's entity_name column
    final entityName =
        _extractEntityName() ?? dummyRowData['entity_name']?.toString();
    if (entityName == null) {
      throw StateError(
        'tree() requires entity_name but none found. '
        'Either add operations to the render spec or include an entity_name column in the query.',
      );
    }

    final treeContext = RenderContext(
      rowData: dummyRowData,
      rowTemplates: renderSpec.rowTemplates,
      onOperation: onOperation,
      entityName: entityName,
      rowCache: queryState.rowCache,
      parentIdColumn: parentIdColumn,
      sortKeyColumn: sortKeyColumn,
      colors: colors,
      queryParams: queryParams,
    );

    return interpreter.build(rootExpr, treeContext);
  }

  /// Build OutlinerListView from outline() function.
  Widget _buildOutlineView(
    WidgetRef ref,
    ReactiveQueryState queryState,
    List<Arg> outlineArgs,
    RenderInterpreter interpreter,
    AppColors colors,
  ) {
    final parentIdArg = outlineArgs.firstWhere(
      (arg) => arg.name == 'parent_id',
      orElse: () =>
          throw ArgumentError('outline() requires "parent_id" argument'),
    );
    final sortKeyArg = outlineArgs.firstWhere(
      (arg) => arg.name == 'sortkey' || arg.name == 'sort_key',
      orElse: () => throw ArgumentError(
        'outline() requires "sortkey" or "sort_key" argument',
      ),
    );
    final itemTemplateArg = outlineArgs.firstWhere(
      (arg) => arg.name == 'item_template' || arg.name == 'item',
      orElse: () => throw ArgumentError(
        'outline() requires "item_template" or "item" argument',
      ),
    );

    final parentIdColumn = _evaluateColumnName(parentIdArg.value);
    final sortKeyColumn = _evaluateColumnName(sortKeyArg.value);

    // Extract entity name from: operations, then first row's entity_name column
    final firstRow = queryState.rowCache.values.isNotEmpty
        ? queryState.rowCache.values.first
        : <String, dynamic>{};
    final entityName =
        _extractEntityName() ?? firstRow['entity_name']?.toString();
    if (entityName == null) {
      throw StateError(
        'outline() requires entity_name but none found. '
        'Either add operations to the render spec or include an entity_name column in the query.',
      );
    }

    // Get or create blockOps from notifier
    final notifier = ref.read(reactiveQueryStateProvider(queryParams).notifier);
    var blockOps = queryState.blockOps;
    if (blockOps == null) {
      blockOps = RowDataBlockOps(
        rowCache: queryState.rowCache,
        parentIdColumn: parentIdColumn,
        sortKeyColumn: sortKeyColumn,
        entityName: entityName,
        onOperation: onOperation,
      );
      notifier.setBlockOps(blockOps);
    }

    // Update blockOps cache
    for (final entry in queryState.rowCache.entries) {
      blockOps.updateRowCache(entry.key, entry.value);
    }

    final opsProvider = Provider<BlockOps<Map<String, dynamic>>>((ref) {
      return blockOps!;
    });

    final notifierProvider =
        NotifierProvider<
          OutlinerNotifier<Map<String, dynamic>>,
          OutlinerState<Map<String, dynamic>>
        >(() {
          return OutlinerNotifier<Map<String, dynamic>>(blockOps!);
        });

    final itemTemplate = itemTemplateArg.value;

    return ProviderScope(
      overrides: [opsProvider.overrideWithValue(blockOps)],
      child: OutlinerListView<Map<String, dynamic>>(
        opsProvider: opsProvider,
        notifierProvider: notifierProvider,
        config: const OutlinerConfig(
          keyboardShortcutsEnabled: true,
          padding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        ),
        blockBuilder: (buildContext, block) {
          final blockContext = RenderContext(
            rowData: block,
            rowTemplates: renderSpec.rowTemplates,
            onOperation: onOperation,
            entityName: entityName,
            rowCache: queryState.rowCache,
            parentIdColumn: parentIdColumn,
            sortKeyColumn: sortKeyColumn,
            colors: colors,
          );
          return interpreter.build(itemTemplate, blockContext);
        },
      ),
    );
  }

  /// Evaluate column name from RenderExpr
  String _evaluateColumnName(RenderExpr expr) {
    return expr.when(
      columnRef: (name) => name,
      literal: (value) {
        final dynamicValue = valueToDynamic(value);
        if (dynamicValue is String) {
          return dynamicValue;
        }
        throw ArgumentError(
          'Column name must be a string literal or column reference',
        );
      },
      functionCall: (_, __, ___) =>
          throw ArgumentError('Column name cannot be a function call'),
      binaryOp: (_, __, ___) =>
          throw ArgumentError('Column name cannot be a binary operation'),
      array: (_) => throw ArgumentError('Column name cannot be an array'),
      object: (_) => throw ArgumentError('Column name cannot be an object'),
    );
  }

  /// Extract entity name from render spec or operations
  String? _extractEntityName() {
    final rootExpr = renderSpec.getViewStructure(viewName);
    return rootExpr.when(
      functionCall: (name, args, operations) {
        if (operations.isNotEmpty) {
          return operations.first.descriptor.entityName.isNotEmpty
              ? operations.first.descriptor.entityName
              : null;
        }
        return null;
      },
      columnRef: (_) => null,
      literal: (_) => null,
      binaryOp: (_, __, ___) => null,
      array: (_) => null,
      object: (_) => null,
    );
  }

  /// Build single item (non-list rendering).
  Widget _buildSingleItem(
    ReactiveQueryState queryState,
    RenderExpr expr,
    RenderInterpreter interpreter,
    AppColors colors,
  ) {
    if (queryState.rowCache.isEmpty) {
      return const Center(child: Text('No data'));
    }

    final rowId = queryState.rowOrder.first;
    final rowData = queryState.rowCache[rowId]!;
    debugPrint(
      '[ReactiveQueryWidget] Building single item row=$rowId content="${rowData['content']}"',
    );

    final renderContext = RenderContext(
      rowData: rowData,
      rowTemplates: renderSpec.rowTemplates,
      onOperation: onOperation,
      rowIndex: 0,
      previousRowData: null,
      colors: colors,
    );

    return interpreter.build(expr, renderContext);
  }
}

