// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import '../third_party/holon_api.dart';
import '../third_party/holon_api/render_types.dart';
import '../third_party/holon_api/streaming.dart';
import '../third_party/holon_api/widget_spec.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// These functions are ignored because they are not marked as `pub`: `create_span_from_context`, `default_env_filter`, `get_session`, `init_opentelemetry`, `spawn_stream_forwarder`

/// Initialize the render engine with a database at the given path
///
/// This is the main entry point for Flutter. It creates a `FrontendSession` which:
/// 1. Initializes the database and schema (including materialized views)
/// 2. Waits for file watcher readiness (if OrgMode is configured)
/// 3. Detects any startup errors
///
/// The session is stored globally so that subsequent FFI calls can access it.
/// All query methods go through `FrontendSession`, ensuring they can only be
/// called after initialization completes.
///
/// # Parameters
/// * `db_path` - Path to the database file
/// * `config` - Configuration map containing:
///   - `TODOIST_API_KEY` - Todoist API key for sync
///   - `ORGMODE_ROOT_DIRECTORY` - OrgMode files root directory
///   - `MCP_SERVER_PORT` - Port for MCP HTTP server (optional, starts server if provided)
///
/// # Returns
/// An opaque handle to the session. The actual `FrontendSession` is stored globally
/// and accessed by subsequent FFI calls. This return value is kept alive by Flutter
/// to prevent the Rust Bridge from disposing the underlying resources.
Future<ArcFrontendSession> initRenderEngine({
  required String dbPath,
  required Map<String, String> config,
}) => RustLib.instance.api.crateApiFfiBridgeInitRenderEngine(
  dbPath: dbPath,
  config: config,
);

/// Compile a PRQL query, execute it, and set up CDC streaming
///
/// This combines query compilation, execution, and change watching into a single call.
/// Returns a WidgetSpec (render spec + data) and forwards CDC events to the sink.
///
/// # Returns
/// - `WidgetSpec`: Contains render_spec and data (actions empty for regular queries)
///
/// # UI Usage
/// The UI should:
/// 1. Subscribe to the MapChangeSink using StreamBuilder in Flutter
/// 2. Key widgets by entity ID from data.get("id"), NOT by rowid
/// 3. Handle Added/Updated/Removed events to update UI
///
Future<WidgetSpec> queryAndWatch({
  required String prql,
  required Map<String, Value> params,
  required MapChangeSink sink,
  TraceContext? traceContext,
  String? contextBlockId,
}) => RustLib.instance.api.crateApiFfiBridgeQueryAndWatch(
  prql: prql,
  params: params,
  sink: sink,
  traceContext: traceContext,
  contextBlockId: contextBlockId,
);

/// Get available operations for an entity
///
/// Returns a list of operation descriptors available for the given entity_name.
/// Use "*" as entity_name to get wildcard operations.
///
/// # FFI Function
/// This is exposed to Flutter via flutter_rust_bridge
Future<List<OperationDescriptor>> availableOperations({
  required String entityName,
}) => RustLib.instance.api.crateApiFfiBridgeAvailableOperations(
  entityName: entityName,
);

/// Execute an operation on the database
///
/// # FFI Function
/// This is exposed to Flutter via flutter_rust_bridge
///
/// Operations mutate the database directly. UI updates happen via CDC streams.
/// This follows the unidirectional data flow: Action → Model → View
///
/// # Note
/// This function does NOT return new data. Changes propagate through:
/// Operation → DB mutation → CDC event → watch_query stream → UI update
Future<void> executeOperation({
  required String entityName,
  required String opName,
  required Map<String, Value> params,
  TraceContext? traceContext,
}) => RustLib.instance.api.crateApiFfiBridgeExecuteOperation(
  entityName: entityName,
  opName: opName,
  params: params,
  traceContext: traceContext,
);

/// Check if an operation is available for an entity
///
/// # FFI Function
/// This is exposed to Flutter via flutter_rust_bridge
///
/// # Returns
/// `true` if the operation is available, `false` otherwise
Future<bool> hasOperation({
  required String entityName,
  required String opName,
}) => RustLib.instance.api.crateApiFfiBridgeHasOperation(
  entityName: entityName,
  opName: opName,
);

/// Undo the last operation
///
/// Executes the inverse operation from the undo stack and pushes it to the redo stack.
/// Returns true if an operation was undone, false if the undo stack is empty.
Future<bool> undo() => RustLib.instance.api.crateApiFfiBridgeUndo();

/// Redo the last undone operation
///
/// Executes the inverse of the last undone operation and pushes it back to the undo stack.
/// Returns true if an operation was redone, false if the redo stack is empty.
Future<bool> redo() => RustLib.instance.api.crateApiFfiBridgeRedo();

/// Check if undo is available
Future<bool> canUndo() => RustLib.instance.api.crateApiFfiBridgeCanUndo();

/// Check if redo is available
Future<bool> canRedo() => RustLib.instance.api.crateApiFfiBridgeCanRedo();

/// Get the initial widget for the application root
///
/// This is the main entry point for the backend-driven UI architecture.
/// Returns a WidgetSpec containing:
/// - render_spec: How to render the layout (e.g., columns with regions)
/// - data: The layout data (region blocks with widths, content, etc.)
/// - actions: Global actions available throughout the app
///
/// The frontend renders this using RenderInterpreter, just like any other widget.
/// CDC events are forwarded to the provided sink for live updates.
///
/// **This method can only be called after `init_render_engine` completes.**
/// The type system enforces this: `FrontendSession` (stored in `GLOBAL_SESSION`)
/// is only available after initialization, so `initial_widget` cannot be called
/// before the schema (including `blocks_with_paths`) is ready.
///
/// # Example usage in Flutter:
/// ```dart
/// final widgetSpec = await initialWidget(sink);
/// // Use RenderInterpreter to render the widget
/// final widget = RenderInterpreter().build(widgetSpec.renderSpec, context);
/// ```
Future<WidgetSpec> initialWidget({required MapChangeSink sink}) =>
    RustLib.instance.api.crateApiFfiBridgeInitialWidget(sink: sink);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ArcFrontendSession>>
abstract class ArcFrontendSession implements RustOpaqueInterface {}

/// flutter_rust_bridge:non_opaque
class MapChangeSink {
  final RustStreamSink<BatchMapChangeWithMetadata> sink;

  const MapChangeSink({required this.sink});

  @override
  int get hashCode => sink.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MapChangeSink &&
          runtimeType == other.runtimeType &&
          sink == other.sink;
}
