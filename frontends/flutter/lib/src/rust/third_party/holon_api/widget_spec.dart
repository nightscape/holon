// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import '../holon_api.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'render_types.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `new`, `with_action`, `with_actions`, `with_icon`, `with_param`

/// Operation to execute for an action
///
/// flutter_rust_bridge:non_opaque
class ActionOperation {
  /// Entity name (e.g., "*" for wildcard operations)
  final String entityName;

  /// Operation name (e.g., "sync_from_remote")
  final String opName;

  /// Default parameters for this operation
  final Map<String, Value> params;

  const ActionOperation({
    required this.entityName,
    required this.opName,
    required this.params,
  });

  @override
  int get hashCode => entityName.hashCode ^ opName.hashCode ^ params.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ActionOperation &&
          runtimeType == other.runtimeType &&
          entityName == other.entityName &&
          opName == other.opName &&
          params == other.params;
}

/// Specification for a global action
///
/// Actions are operations that can be triggered from anywhere in the app,
/// like sync, settings, or undo/redo.
///
/// flutter_rust_bridge:non_opaque
class ActionSpec {
  /// Unique identifier
  final String id;

  /// Human-readable display name
  final String displayName;

  /// Optional icon name (e.g., "sync", "settings")
  final String? icon;

  /// The operation to execute when this action is triggered
  final ActionOperation operation;

  const ActionSpec({
    required this.id,
    required this.displayName,
    this.icon,
    required this.operation,
  });

  @override
  int get hashCode =>
      id.hashCode ^ displayName.hashCode ^ icon.hashCode ^ operation.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ActionSpec &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          displayName == other.displayName &&
          icon == other.icon &&
          operation == other.operation;
}

/// Specification for rendering a widget
///
/// WidgetSpec is the unified type returned by query_and_watch and initial_widget.
/// It contains everything the frontend needs to render:
/// - render_spec: How to render (e.g., columns, list, tree)
/// - data: The query result data (rows)
/// - actions: Available actions (may be empty for non-root widgets)
///
/// The change stream is returned separately (not in this struct) since
/// streams are not serializable for FFI.
///
/// flutter_rust_bridge:non_opaque
class WidgetSpec {
  /// Render spec defining how to render (parsed from PRQL render directive)
  final RenderSpec renderSpec;

  /// Query result data (rows to render)
  final List<Map<String, Value>> data;

  /// Available actions (global actions for root, contextual for others)
  final List<ActionSpec> actions;

  const WidgetSpec({
    required this.renderSpec,
    required this.data,
    required this.actions,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Create a new WidgetSpec
  static Future<WidgetSpec> newInstance({
    required RenderSpec renderSpec,
    required List<Map<String, Value>> data,
  }) => RustLib.instance.api.holonApiWidgetSpecWidgetSpecNew(
    renderSpec: renderSpec,
    data: data,
  );

  @override
  int get hashCode => renderSpec.hashCode ^ data.hashCode ^ actions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WidgetSpec &&
          runtimeType == other.runtimeType &&
          renderSpec == other.renderSpec &&
          data == other.data &&
          actions == other.actions;
}
