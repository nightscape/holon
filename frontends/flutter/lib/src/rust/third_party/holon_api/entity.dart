// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../holon_api.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'entity.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `get_mut`, `get`
// These functions are ignored (category: IgnoreBecauseType): `from_entity`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `default`, `get_bool`, `get_f64`, `get_i64`, `get_string`, `has_field`, `new`, `remove`, `set`, `with_field`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `from_table_name`, `indexed`, `jsonb`, `new`, `new`, `nullable`, `primary_key`

abstract class HasSchema {
  /// Convert this entity to a dynamic representation
  Future<DynamicEntity> toEntity();
}

/// A dynamic entity with runtime-determined fields.
///
/// This provides a type-erased representation of any entity,
/// useful for generic storage and serialization.
///
/// flutter_rust_bridge:ignore
class DynamicEntity {
  final String typeName;
  final Map<String, Value> fields;

  const DynamicEntity({required this.typeName, required this.fields});

  @override
  int get hashCode => typeName.hashCode ^ fields.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DynamicEntity &&
          runtimeType == other.runtimeType &&
          typeName == other.typeName &&
          fields == other.fields;
}

/// Schema for a field in an entity.
/// flutter_rust_bridge:non_opaque
class EntityFieldSchema {
  final String name;
  final FieldType fieldType;
  final bool required_;
  final bool indexed;

  const EntityFieldSchema({
    required this.name,
    required this.fieldType,
    required this.required_,
    required this.indexed,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      fieldType.hashCode ^
      required_.hashCode ^
      indexed.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EntityFieldSchema &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          fieldType == other.fieldType &&
          required_ == other.required_ &&
          indexed == other.indexed;
}

/// Complete schema for an entity type.
///
/// Used by the Entity macro to store metadata about the entity.
/// flutter_rust_bridge:non_opaque
class EntitySchema {
  final String name;
  final List<EntityFieldSchema> fields;
  final String primaryKey;

  const EntitySchema({
    required this.name,
    required this.fields,
    required this.primaryKey,
  });

  @override
  int get hashCode => name.hashCode ^ fields.hashCode ^ primaryKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EntitySchema &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          fields == other.fields &&
          primaryKey == other.primaryKey;
}

/// Schema for a single field in a table.
class FieldSchema {
  final String name;
  final String sqlType;
  final bool nullable;
  final bool primaryKey;
  final bool indexed;
  final bool isJsonb;

  const FieldSchema({
    required this.name,
    required this.sqlType,
    required this.nullable,
    required this.primaryKey,
    required this.indexed,
    required this.isJsonb,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      sqlType.hashCode ^
      nullable.hashCode ^
      primaryKey.hashCode ^
      indexed.hashCode ^
      isJsonb.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FieldSchema &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          sqlType == other.sqlType &&
          nullable == other.nullable &&
          primaryKey == other.primaryKey &&
          indexed == other.indexed &&
          isJsonb == other.isJsonb;
}

@freezed
sealed class FieldType with _$FieldType {
  const FieldType._();

  const factory FieldType.string() = FieldType_String;
  const factory FieldType.integer() = FieldType_Integer;
  const factory FieldType.boolean() = FieldType_Boolean;
  const factory FieldType.dateTime() = FieldType_DateTime;
  const factory FieldType.json() = FieldType_Json;
  const factory FieldType.reference(String field0) = FieldType_Reference;

  /// Convert to SQLite type string
  Future<void> toSqliteType() =>
      RustLib.instance.api.holonApiEntityFieldTypeToSqliteType(that: this);
}

/// Schema for a database table, used for DDL generation.
class Schema {
  final String tableName;
  final List<FieldSchema> fields;

  const Schema({required this.tableName, required this.fields});

  /// Check if a field is marked as JSONB
  Future<bool> fieldIsJsonb({required String fieldName}) => RustLib.instance.api
      .holonApiEntitySchemaFieldIsJsonb(that: this, fieldName: fieldName);

  /// Generate CREATE TABLE SQL statement
  Future<String> toCreateTableSql() =>
      RustLib.instance.api.holonApiEntitySchemaToCreateTableSql(that: this);

  /// Generate CREATE INDEX SQL statements for indexed fields
  Future<List<String>> toIndexSql() =>
      RustLib.instance.api.holonApiEntitySchemaToIndexSql(that: this);

  @override
  int get hashCode => tableName.hashCode ^ fields.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Schema &&
          runtimeType == other.runtimeType &&
          tableName == other.tableName &&
          fields == other.fields;
}
