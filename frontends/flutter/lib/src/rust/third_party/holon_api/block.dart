// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../holon_api.dart';
import 'entity.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'block.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BlockWithDepth`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `as_source`, `as_text`, `content_text`, `depth_from`, `get_header_arg`, `get_property_str`, `get_property`, `get_source_header_args`, `get_source_results`, `is_prql_block`, `is_source_block`, `metadata`, `properties_map`, `set_block_content`, `set_metadata`, `set_properties_map`, `set_source_header_args`, `set_source_results`, `short_name`, `title`, `to_block_content`, `to_plain_text`
// These functions are ignored (category: IgnoreBecauseType): `from_entity`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `error`, `from_block_content`, `new_source`, `new_text`, `new`, `set_property`, `source`, `text`, `text`, `with_header_arg`, `with_name`

/// A block in the hierarchical document structure.
///
/// This struct is flattened for efficient database storage while maintaining
/// a rich API through helper methods. Complex types (properties, children,
/// source block metadata) are stored as JSON strings.
///
/// Blocks use URI-based IDs to support integration with external systems:
/// - Local blocks: `local://<uuid-v4>` (e.g., `local://550e8400-e29b-41d4-a716-446655440000`)
/// - External systems: `todoist://task/12345`, `logseq://page/abc123`
///
/// # Example
///
/// ```rust
/// use holon_api::Block;
///
/// // Text block
/// let block = Block::new_text("block-1", "__root_parent__", "My first block");
///
/// // PRQL source block
/// let query_block = Block::new_source("query-1", "__root_parent__", "prql", "from tasks");
/// ```
/// flutter_rust_bridge:non_opaque
class Block {
  /// URI-based unique identifier
  final String id;

  /// Parent block ID
  final String parentId;

  /// Text content (raw text or source code)
  final String content;

  /// Content type: "text" or "source"
  final String contentType;

  /// For source blocks: programming language (e.g., "prql", "python")
  final String? sourceLanguage;

  /// For source blocks: optional block name for references (#+NAME: in Org Mode)
  /// Tier 2: Supported in Org Mode and Loro, lost in Markdown
  final String? sourceName;

  /// Key-value properties (TODO, PRIORITY, TAGS, dates, etc.)
  /// Stored as JSON object for native JSON support in Turso.
  /// Tier 2: works fully in Org + Loro
  final Map<String, Value> properties;

  /// Unix timestamp (milliseconds) when block was created
  final PlatformInt64 createdAt;

  /// Unix timestamp (milliseconds) when block was last updated
  final PlatformInt64 updatedAt;

  const Block({
    required this.id,
    required this.parentId,
    required this.content,
    required this.contentType,
    this.sourceLanguage,
    this.sourceName,
    required this.properties,
    required this.createdAt,
    required this.updatedAt,
  });

  static Future<Block> default_() =>
      RustLib.instance.api.holonApiBlockBlockDefault();

  static Future<EntitySchema> entitySchema() =>
      RustLib.instance.api.holonApiBlockBlockEntitySchema();

  static Future<Schema> schema() =>
      RustLib.instance.api.holonApiBlockBlockSchema();

  Future<DynamicEntity> toEntity() =>
      RustLib.instance.api.holonApiBlockBlockToEntity(that: this);

  @override
  int get hashCode =>
      id.hashCode ^
      parentId.hashCode ^
      content.hashCode ^
      contentType.hashCode ^
      sourceLanguage.hashCode ^
      sourceName.hashCode ^
      properties.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Block &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          parentId == other.parentId &&
          content == other.content &&
          contentType == other.contentType &&
          sourceLanguage == other.sourceLanguage &&
          sourceName == other.sourceName &&
          properties == other.properties &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;
}

@freezed
sealed class BlockContent with _$BlockContent {
  const BlockContent._();

  /// Plain text content (paragraphs, prose)
  const factory BlockContent.text({
    /// Raw text content
    required String raw,
  }) = BlockContent_Text;

  /// Source code block (language-agnostic)
  const factory BlockContent.source(SourceBlock field0) = BlockContent_Source;

  static Future<BlockContent> default_() =>
      RustLib.instance.api.holonApiBlockBlockContentDefault();
}

/// Metadata associated with a block.
///
/// Note: UI state like `collapsed` is NOT stored here - it's kept locally
/// in the frontend to avoid cross-user UI churn in collaborative sessions.
/// flutter_rust_bridge:non_opaque
class BlockMetadata {
  /// Unix timestamp (milliseconds) when block was created
  final PlatformInt64 createdAt;

  /// Unix timestamp (milliseconds) when block was last updated
  final PlatformInt64 updatedAt;

  const BlockMetadata({required this.createdAt, required this.updatedAt});

  static Future<BlockMetadata> default_() =>
      RustLib.instance.api.holonApiBlockBlockMetadataDefault();

  @override
  int get hashCode => createdAt.hashCode ^ updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BlockMetadata &&
          runtimeType == other.runtimeType &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;
}

/// Results from executing a source block.
///
/// flutter_rust_bridge:non_opaque
class BlockResult {
  /// The output content
  final ResultOutput output;

  /// Unix timestamp (milliseconds) when the block was executed
  final PlatformInt64 executedAt;

  const BlockResult({required this.output, required this.executedAt});

  /// Create a table result
  static Future<BlockResult> table({
    required List<String> headers,
    required List<List<Value>> rows,
  }) => RustLib.instance.api.holonApiBlockBlockResultTable(
    headers: headers,
    rows: rows,
  );

  @override
  int get hashCode => output.hashCode ^ executedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BlockResult &&
          runtimeType == other.runtimeType &&
          output == other.output &&
          executedAt == other.executedAt;
}

@freezed
sealed class ResultOutput with _$ResultOutput {
  const ResultOutput._();

  /// Plain text output
  const factory ResultOutput.text({required String content}) =
      ResultOutput_Text;

  /// Tabular output (from queries)
  const factory ResultOutput.table({
    required List<String> headers,
    required List<List<Value>> rows,
  }) = ResultOutput_Table;

  /// Error output
  const factory ResultOutput.error({required String message}) =
      ResultOutput_Error;
}

/// A source code block with optional metadata.
///
/// Supports three tiers of features:
/// - Tier 1 (all formats): language + source code
/// - Tier 2 (Org + Loro): name, header_args, results
/// - Tier 3 (Loro only): inherited from Block's CRDT features
///
/// In Org Mode: `#+BEGIN_SRC language :arg1 val1 ... #+END_SRC`
/// In Markdown: ` ```language ... ``` `
/// In Loro: Native storage with full fidelity
///
/// flutter_rust_bridge:non_opaque
class SourceBlock {
  /// Language identifier (e.g., "prql", "sql", "python", "rust")
  final String? language;

  /// The source code itself
  final String source;

  /// Optional block name for references (#+NAME: in Org Mode)
  /// Tier 2: Supported in Org Mode and Loro, lost in Markdown
  final String? name;

  /// Header arguments / parameters
  /// Tier 2: Supported in Org Mode (`:var x=1 :results table`) and Loro
  /// Examples for PRQL: { "connection": "main", "results": "table" }
  final Map<String, Value> headerArgs;

  const SourceBlock({
    this.language,
    required this.source,
    this.name,
    required this.headerArgs,
  });

  /// Check if this is a PRQL source block
  Future<bool> isPrql() =>
      RustLib.instance.api.holonApiBlockSourceBlockIsPrql(that: this);

  @override
  int get hashCode =>
      language.hashCode ^ source.hashCode ^ name.hashCode ^ headerArgs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SourceBlock &&
          runtimeType == other.runtimeType &&
          language == other.language &&
          source == other.source &&
          name == other.name &&
          headerArgs == other.headerArgs;
}
