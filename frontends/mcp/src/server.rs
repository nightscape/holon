use holon::api::backend_engine::BackendEngine;
use rmcp::{
    handler::server::router::tool::ToolRouter, model::*, service::RequestContext, tool_handler,
    ErrorData as McpError, RoleServer, ServerHandler,
};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;
use tokio::task::JoinHandle;

use crate::types::RowChangeJson;

pub struct WatchState {
    pub pending_changes: Arc<Mutex<Vec<RowChangeJson>>>,
    pub _task_handle: JoinHandle<()>,
}

pub struct HolonMcpServer {
    pub engine: Arc<BackendEngine>,
    pub watches: Arc<Mutex<HashMap<String, WatchState>>>,
    pub(crate) tool_router: ToolRouter<HolonMcpServer>,
}

impl HolonMcpServer {
    pub fn new(engine: Arc<BackendEngine>) -> Self {
        // Initialize tool_router using the macro-generated function from tools.rs
        // The #[tool_router] macro generates a tool_router() associated function
        let tool_router = {
            // Call the tool_router function that's generated by the macro in tools.rs
            // This is a bit of a workaround since the macro generates a private function
            // We'll use a helper function in tools.rs to expose it
            crate::tools::get_tool_router()
        };

        Self {
            engine,
            watches: Arc::new(Mutex::new(HashMap::new())),
            tool_router,
        }
    }
}

#[tool_handler]
impl ServerHandler for HolonMcpServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            instructions: Some("Holon backend engine MCP server for automated testing".into()),
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .enable_resources()
                .enable_completions()
                .build(),
            server_info: Implementation::from_build_env(),
            ..Default::default()
        }
    }

    async fn list_resources(
        &self,
        request: Option<PaginatedRequestParam>,
        ctx: RequestContext<RoleServer>,
    ) -> Result<ListResourcesResult, McpError> {
        self.list_resources_impl(request, ctx).await
    }

    async fn read_resource(
        &self,
        request: ReadResourceRequestParam,
        ctx: RequestContext<RoleServer>,
    ) -> Result<ReadResourceResult, McpError> {
        self.read_resource_impl(request, ctx).await
    }

    async fn complete(
        &self,
        _request: CompleteRequestParam,
        _ctx: RequestContext<RoleServer>,
    ) -> Result<CompleteResult, McpError> {
        // Return empty completions - we don't provide argument completions yet
        Ok(CompleteResult {
            completion: CompletionInfo {
                values: vec![],
                has_more: Some(false),
                total: Some(0),
            },
            ..Default::default()
        })
    }
}
